# =============================================================================
# Danube Connect - MQTT Source Connector Configuration
# =============================================================================
#
# This is a SINGLE configuration file that contains:
#   1. Core Danube framework settings (at root level)
#   2. MQTT connector-specific settings (under [mqtt] section)
#
# Usage:
#   export CONNECTOR_CONFIG_PATH=/path/to/connector.toml
#   docker run -v ./connector.toml:/etc/connector.toml:ro \
#              -e CONNECTOR_CONFIG_PATH=/etc/connector.toml \
#              mqtt-connector
#
# ENV Variable Overrides:
#   Only secrets and connection URLs can be overridden with environment variables
#   Example: MQTT_PASSWORD=secret DANUBE_SERVICE_URL=http://prod:6650
#
# =============================================================================

# -----------------------------------------------------------------------------
# Core Danube Connect Settings (Common to All Connectors)
# -----------------------------------------------------------------------------

# Mandatory fields (can be overridden by DANUBE_SERVICE_URL and CONNECTOR_NAME env vars)
danube_service_url = "http://danube-broker:6650"
connector_name = "mqtt-iot-source"

# Retry settings (optional, these are defaults)
[retry]
max_retries = 3
retry_backoff_ms = 1000
max_backoff_ms = 30000

# Processing and runtime settings (optional, these are defaults)
[processing]
batch_size = 1000
batch_timeout_ms = 1000
poll_interval_ms = 100
metrics_port = 9090
log_level = "info"

# -----------------------------------------------------------------------------
# MQTT Connector Settings
# -----------------------------------------------------------------------------

[mqtt]
# MQTT broker connection settings
broker_host = "mosquitto"
broker_port = 1883
client_id = "danube-connector-1"

# Authentication (optional)
# username = "mqtt_user"
# password = "mqtt_pass"

# TLS/SSL settings
use_tls = false

# Connection parameters
keep_alive_secs = 60
connection_timeout_secs = 30
max_packet_size = 10485760  # 10 MB

# Session settings
clean_session = true
include_metadata = true

# ============================================================================
# Topic Mappings
# Define which MQTT topics to subscribe to and where to route them in Danube
# 
# MQTT Topic Patterns: Supports wildcards (+ for single level, # for multi-level)
# Danube Topic Format: /{namespace}/{topic_name} (exactly 2 segments)
#   - Valid:   /iot/sensors, /default/telemetry, /prod/temperature
#   - Invalid: /iot/sensors/zone1, /a/b/c (more than 2 segments)
#
# Reliable Dispatch (per-topic):
#   - QoS 0 (AtMostOnce)  → reliable_dispatch defaults to false
#   - QoS 1 (AtLeastOnce) → reliable_dispatch defaults to true
#   - QoS 2 (ExactlyOnce) → reliable_dispatch defaults to true
# ============================================================================

# Example 1: High-volume sensor data from zone1 (partitioned for scale)
[[mqtt.topic_mappings]]
mqtt_topic = "sensors/+/zone1"
danube_topic = "/iot/sensors_zone1"  # Format: /{namespace}/{topic_name}
qos = "AtLeastOnce"  # QoS 1 - will use reliable dispatch
partitions = 4       # Partitioned topic for high throughput
# reliable_dispatch is automatically true for QoS 1 (can override if needed)

# Example 2: Device telemetry (partitioned, reliable)
[[mqtt.topic_mappings]]
mqtt_topic = "devices/+/telemetry"
danube_topic = "/iot/device_telemetry"  # Format: /{namespace}/{topic_name}
qos = "AtLeastOnce"  # QoS 1
partitions = 2
# reliable_dispatch defaults to true for QoS 1

# Example 3: Temperature data (non-partitioned, reliable)
[[mqtt.topic_mappings]]
mqtt_topic = "sensors/temp/#"
danube_topic = "/iot/temperature"
qos = "AtLeastOnce"  # QoS 1
partitions = 0       # Non-partitioned topic
# reliable_dispatch defaults to true for QoS 1

# Example 4: Low-priority debug logs (non-reliable, fast)
[[mqtt.topic_mappings]]
mqtt_topic = "debug/#"
danube_topic = "/iot/debug"
qos = "AtMostOnce"           # QoS 0 - fire and forget
partitions = 0               # Non-partitioned
# reliable_dispatch defaults to false for QoS 0

# Example 5: Critical alarms (reliable, non-partitioned for ordering)
# [[mqtt.topic_mappings]]
# mqtt_topic = "alarms/critical/#"
# danube_topic = "/iot/alarms"
# qos = "ExactlyOnce"  # QoS 2
# partitions = 0       # Non-partitioned to preserve strict ordering
# reliable_dispatch = true

# ============================================================================
# QoS Levels Explained:
# - 0 (AtMostOnce):  Fire and forget, fastest but may lose messages
# - 1 (AtLeastOnce): Guaranteed delivery, may receive duplicates
# - 2 (ExactlyOnce): Guaranteed exactly once, slowest but most reliable
# ============================================================================

# ============================================================================
# Environment Variable Overrides
# ============================================================================
# Environment variables are used ONLY for secrets and environment-specific values:
#
# Required:
#   CONNECTOR_CONFIG_PATH=/etc/connector.toml  # Path to this config file
#
# Core Danube settings (optional overrides):
#   DANUBE_SERVICE_URL=http://broker:6650     # Override broker URL for different environments
#   CONNECTOR_NAME=my-connector               # Override connector name for different deployments
#
# MQTT connection settings (optional overrides):
#   MQTT_BROKER_HOST=mosquitto                # Override broker host (dev/staging/prod)
#   MQTT_BROKER_PORT=1883                     # Override broker port
#   MQTT_CLIENT_ID=connector-1                # Override client ID
#   MQTT_USERNAME=user                        # Secret - should NOT be in TOML
#   MQTT_PASSWORD=pass                        # Secret - should NOT be in TOML
#   MQTT_USE_TLS=true                         # Override TLS setting
#
# NOT supported via environment variables:
#   - Topic mappings (must be in TOML)
#   - Retry settings (must be in TOML)
#   - Processing settings (must be in TOML)
#   - Connection parameters (keep_alive, timeouts, etc. - must be in TOML)
#
# This design is especially useful for:
# - Secrets (passwords, tokens) in production via env vars
# - Deployment-specific URLs via env vars
# - Static configuration (retry, processing, topics) in version-controlled TOML
# - Kubernetes ConfigMaps (TOML file) and Secrets (env vars)
# ============================================================================
